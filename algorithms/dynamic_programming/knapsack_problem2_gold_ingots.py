"""
Задача золотые слитки.
Есть n золотых слитков массами m. Какую максимальную массу золота можно унести, если она не может превышать MAX_MASS.
mass_possible - список значений True и False, обозначающих можно ли набрать слитков на массу в точности mass.
Будем по очереди рассматривать все слитки, обновляя значения mass_possible.
При рассмотрении слитка ingot[i] необходимо пометить mass_possible[ingot[i]] = True,
если mass_possible[mass - ingot[i]] = True, то есть если массу mass в точности  можно набрать,
если ранее было возможно набрать массу mass - ingot[i].
"""

MAX_MASS = 17
ingots = [3, 5, 7, 8, 9, 10]
mass_possible = [0] * (MAX_MASS + 1)
mass_possible[0] = 1
temp = [0] * (MAX_MASS + 1)
ans = []

"""
Внутренний цикл проходит массы в обратном порядке до массы рассматриваемого слитка (меньше него смотреть не имеет смысла,
это нижняя граница). Обратный порядок берётся потому что нельзя вносить исправления сразу же в список.
Иначе один предмет будет учтен более одного раза, то есть будут помечены единицами ingot, затем - 2*ingot, так как 
mass_possible[ingot] = 1, затем 3*ingot и т.д.
"""
for ingot in ingots:
    # массы заканчиваем рассматривать на значении mass=ingot, так как массу можно набрать, только если можно было
    # набрать массу mass-ingot, то есть ingot - минимальное значения для рассматриваемой массы.
    for mass in range(MAX_MASS, ingot-1, -1):
        if mass_possible[mass-ingot]:
            # Для каждой массы, будем хранить слиток, с помощью которого можно получить эту mass.
            # mass будет индексом, значением будет масса слитка.
            # Если выбирать ситуацию, где не было сведений о том, что данную массу уже можно получить,
            # мы будем сохранять слитки минимальной массы для набора данной массы.
            if not mass_possible[mass]:
                temp[mass] = ingot
            # Если просто сохранять в список слиток, то мы получим список слитков максимальной массы для реализации.
            # temp[mass] = ingot
            mass_possible[mass] = 1
print(mass_possible)

max_possible_mass = MAX_MASS
# Ищем самую правую единичку в списке возможных масс.
# Индекс этой единички - максимальная доступная масса для реализации слитками.
if 1 in mass_possible:
    while not mass_possible[max_possible_mass]:
        max_possible_mass -= 1
print(max_possible_mass)

"""
Восстанавливаем слитки, с помощью которых получается максимально возможная масса. 
Уменьшаем значение текущей массы на ingot, пока не получим 0.
"""
current_mass = max_possible_mass
while current_mass:
    ans.append(temp[current_mass])
    current_mass -= temp[current_mass]

print(ans)
