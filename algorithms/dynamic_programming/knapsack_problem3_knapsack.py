"""
Задача дискретной укладки рюкзака.
Имеется несколько предметов, для каждого предмета заданы две характеристики: вес и стоимость («полезность») предмета.
Необходимо выбрать множество предметов суммарной максимальной стоимости, при этом суммарная масса выбранных предметов
должна быть ограничена значением mass_capacity.
При переборе задача будет иметь сложность О(2**N), но можно реализовать через динамическое программирование
и сложность O(N*mass_capacity).
Как и в задаче про золотые слитки, будем для каждой возможной массы хранить информацию о способе набора этой массы,
но в отличие от задачи про слитки будем хранить не возможность набора данной массы (0 или 1), а наилучшее решение для
данной массы, то есть наибольшую стоимость предметов, которые можно набрать в рюкзак данной массы.
Формально определим так: max_possible_cost(i, mass) - максимальная стоимость предметов, которые можно уложить в рюкзак
массы mass, если можно использовать только первые i предметов.

Выведем рекуррентное соотношение для max_possible_cost уменьшив значение i. Есть две возможности собрать рюкзак,
используя первые i предметов - взять предмет с номером i или не брать.
Если не брать предмет с номером i, то в этом случае max_possible_cost(i, mass) = max_possible_capacity(i-1, mass),
так как рюкзак массы mass будет собран только с использованием первых i предмета.
Если же предмет номер i войдет в рюкзак (это можно сделать только при оставшейся вместимости больше массы предмета), то
останется свободная вместимость рюкзака mass_capacity - item_mass, которую можно будет заполнить первыми i-1 предметом,
максимальная стоимость рюкзака в этом случае будет max_possible_cost(i-1, mass_capacity - mass).
Но поскольку предмет номер i был включен в рюкзак, то стоимость рюкзака увеличится на item_price.
То есть в этом случае max_possible_cost(i, mass) = max_possible_cost(i-1, mass_capacity - mass) + item_price
Из двух вариантов нужно выбрать наибольший по стоимости.

Для хранения значения функции max_possible_cost будем использовать двумерный список.
При этом массы предметов хранятся в списке item_masses, их стоимости - в списке item_prices.
Будем считать (для простоты записи программы), что предметы пронумерованы от 1 до n.
"""

mass_capacity = 43  # целевая стоимость, вместимость в которую рассчитывает алгоритм
item_prices = [1, 2, 3, 4, 5, 7, 8, 9, 11]
item_masses = [1, 4, 6, 3, 6, 4, 8, 7, 6]
number_of_items = len(item_prices)
# пустой двумерный массив, где первый индекс - номер предмета, второй индекс - масса.
max_possible_cost = [[0] * (mass_capacity + 1) for _ in range(number_of_items)]

for i in range(1, number_of_items):
    for mass in range(1, mass_capacity+1):
        if mass >= item_masses[i]:
            max_possible_cost[i][mass] = max(max_possible_cost[i-1][mass],
                                             max_possible_cost[i-1][mass-item_masses[i]] + item_prices[i])
        else:
            max_possible_cost[i][mass] = max_possible_cost[i-1][mass]

ans = []
current_capacity = mass_capacity
# Для восстановления ответа будем перебирать все предметы «с конца» до 1.
# В переменной current_capacity будет храниться текущая вместимость рюкзака.
# Рассматривая предмет номер i определим, как было получено значение max_possible_cost[i][current_capacity].
# Если max_possible_cost[i][current_capacity] = max_possible_cost[i-1][current_capacity], то можно не включать предмет i
# в рюкзак и перейти к предмету i-1 не меняя значения current_capacity.
# Иначе предмет i нужно включить в рюкзак, при этом значение current_capacity уменьшается на item_prices[i].
for i in range(number_of_items-1, 0, -1):
    if max_possible_cost[i][current_capacity] != max_possible_cost[i-1][current_capacity]:
        ans.append(i)
        current_capacity -= item_masses[i]

print(ans)
